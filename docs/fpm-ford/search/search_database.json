var tipuesearch = {"pages":[{"title":" fortran_cubatures ","text":"fortran_cubatures Fortran cubatures About Numerical integration derived type for finite elements in 1D - lineature, line elements, 2D - quadrature, triangle and quadrilateral elements, and 3D - cubature, tetrahedron, hexahedron, and prism/wedge elements. Unit tests verify sum of weights, abscissae means, and polynomial integration. Usage ! Declare type type ( cubature ) :: scheme character ( 3 ) :: geo = \"HEX\" integer :: order = 2 ! Set cubature with geometry and order ! geometry: LINe, TRIangle, QUAdrilateral, TETrahedron, HEXahedron, WEJ (prism) ! order: Integration order (e.g. 1 = single point) call scheme % set ( geo , order ) ! Access element type print * , scheme % elmtype ! Access number of points print * , scheme % points ! Access dimension print * , scheme % dime ! Access weights, shape = [points] print * , scheme % weights ! Access abscissae aka coordinates, shape = [dime, points] print * , scheme % abscissae ! Display scheme call scheme % show () To do Unit testing for prisms Polynomial integration testing with non-separable functions Anisotropic integration for quadrilaterals, hexahedrons, and prisms Developer Info Will Klausler","tags":"home","url":"index.html"},{"title":"Cubature – fortran_cubatures ","text":"type, public :: Cubature This derived type holds data, weights, and abscissae for numerical\nintegration of 2D (triangle, quadrilaterals) and 3D bodies (tetrahedra,\nhexahedra, and wedges) Note: Cubatures for tetrahedra use body coordinates, and the condition\n      x1 + x2 + x3 + x4 = 1 permits the elimination of the final\n      coordinate Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: abscissae (:,:) Abscissae (coordinates) integer(kind=ik), public :: dime = 0 Element dimension character(len=3), public :: elmtype = \"\" Element type: TRI, QUA, TET, HEX, WEJ integer(kind=ik), public :: orders (3) = 0 Order of cubature integer, public :: ounit = stdout integer(kind=ik), public :: points = 0 Number of cubature points real(kind=rk), public, allocatable :: weights (:) Weights Finalization Procedures final :: destroy_final private pure subroutine destroy_final(self) Destroy derived type Arguments Type Intent Optional Attributes Name type( Cubature ), intent(inout) :: self Type-Bound Procedures procedure, public :: check private pure function check(self) Check integrity of derived type Arguments Type Intent Optional Attributes Name class( Cubature ), intent(in) :: self Return Value logical procedure, public :: destroy private pure subroutine destroy(self) wipe data and memory Arguments Type Intent Optional Attributes Name class( Cubature ), intent(inout) :: self procedure, public :: set private pure subroutine set(self, elmtype, order) Set cubature scheme by inputting shape and order Arguments Type Intent Optional Attributes Name class( Cubature ), intent(inout) :: self character(len=3), intent(in) :: elmtype Element type: TRI, QUA, TET, HEX, WEJ integer(kind=ik), intent(in) :: order (:) Cubature order: size 1 or dimension procedure, public :: show private  subroutine show(self) Print cubature scheme to output Arguments Type Intent Optional Attributes Name class( Cubature ), intent(in) :: self procedure, public :: summary private  subroutine summary(self) Summarize cubature scheme Arguments Type Intent Optional Attributes Name class( Cubature ), intent(in) :: self Source Code type :: Cubature !! This derived type holds data, weights, and abscissae for numerical !! integration of 2D (triangle, quadrilaterals) and 3D bodies (tetrahedra, !! hexahedra, and wedges) !! !! Note: Cubatures for tetrahedra use body coordinates, and the condition !!       x1 + x2 + x3 + x4 = 1 permits the elimination of the final !!       coordinate character ( 3 ) :: elmtype = \"\" !! Element type: TRI, QUA, TET, HEX, WEJ integer ( ik ) :: dime = 0 !! Element dimension integer ( ik ) :: orders ( 3 ) = 0 !! Order of cubature integer ( ik ) :: points = 0 !! Number of cubature points real ( rk ), allocatable :: abscissae (:,:) !! Abscissae (coordinates) real ( rk ), allocatable :: weights (:) !! Weights integer :: ounit = stdout contains ! Fulfill object requirements procedure :: check procedure :: summary procedure :: show procedure :: destroy ! Unique procedures procedure :: set final :: destroy_final end type Cubature","tags":"","url":"type/cubature.html"},{"title":"ipolynomial – fortran_cubatures","text":"pure function ipolynomial(c, o) result(v) Evaluate polynomial integral over domain [xlo, xhi] with coefficients\nc to order o\nv = sum_i=1&#94;o+1 c_i/i xhi&#94;i - c_i xlo&#94;i Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: c (10) integer, intent(in) :: o Return Value real(kind=rk) Variables Type Visibility Attributes Name Initial integer, public :: i real(kind=rk), public, parameter :: xhi = 1 real(kind=rk), public, parameter :: xlo = -1 Source Code pure function ipolynomial ( c , o ) result ( v ) !! Evaluate polynomial integral over domain [xlo, xhi] with coefficients !! c to order o !! v = sum_i=1&#94;o+1 c_i/i*xhi&#94;i - c_i*xlo&#94;i real ( rk ), intent ( in ) :: c ( 10 ) integer , intent ( in ) :: o real ( rk ) :: v real ( rk ), parameter :: xlo = - 1 , xhi = 1 integer :: i v = 0 do i = 1 , o + 1 v = v + c ( i ) * ( xhi ** i - xlo ** i ) / i end do ! i end function ipolynomial","tags":"","url":"proc/ipolynomial.html"},{"title":"is_zero – fortran_cubatures","text":"pure elemental function is_zero(r) result(z) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: r Return Value logical Source Code pure elemental function is_zero ( r ) result ( z ) real ( rk ), intent ( in ) :: r logical :: z z = abs ( r ) < 1 0.0_rk ** ( - 12 ) end function is_zero","tags":"","url":"proc/is_zero.html"},{"title":"polynomial – fortran_cubatures","text":"pure function polynomial(c, x, o) result(v) Evaluate polynomial at x with coefficients c to order o\nv = sum_i=1&#94;o+1 c_i*x&#94;(i-1) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: c (10) real(kind=rk), intent(in) :: x integer, intent(in) :: o Return Value real(kind=rk) Variables Type Visibility Attributes Name Initial integer, public :: i Source Code pure function polynomial ( c , x , o ) result ( v ) !! Evaluate polynomial at x with coefficients c to order o !! v = sum_i=1&#94;o+1 c_i*x&#94;(i-1) real ( rk ), intent ( in ) :: c ( 10 ), x integer , intent ( in ) :: o real ( rk ) :: v integer :: i v = c ( 1 ) do i = 2 , o + 1 v = v + c ( i ) * x ** ( i - 1 ) end do ! i end function polynomial","tags":"","url":"proc/polynomial.html"},{"title":"counter – fortran_cubatures","text":"public pure function counter(i, j, k, r) result(c) Count in base r - indexing starts at 1 Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: i integer(kind=ik), intent(in) :: j integer(kind=ik), intent(in) :: k integer(kind=ik), intent(in) :: r (3) Return Value integer(kind=ik) Source Code pure function counter ( i , j , k , r ) result ( c ) !! Count in base r - indexing starts at 1 integer ( ik ), intent ( in ) :: i , j , k , r ( 3 ) integer ( ik ) :: c c = r ( 2 ) * r ( 3 ) * ( i - 1 ) + r ( 3 ) * ( j - 1 ) + ( k - 1 ) + 1 end function counter","tags":"","url":"proc/counter.html"},{"title":"cubatures – fortran_cubatures","text":"Define cubature derived type Uses iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=3), public, parameter :: elmtypes (*) = [\"LIN\", \"TRI\", \"QUA\", \"TET\", \"HEX\", \"WEJ\"] integer, public, parameter :: maxorders (*) = [5, 3, 5, 3, 5, 2] real(kind=rk), public, parameter :: volumes (*) = [2.0_rk, 1.0_rk/2, 4.0_rk, 1.0_rk/6, 8.0_rk, 1.0_rk] Derived Types type, public :: Cubature This derived type holds data, weights, and abscissae for numerical\nintegration of 2D (triangle, quadrilaterals) and 3D bodies (tetrahedra,\nhexahedra, and wedges) Read more… Components Type Visibility Attributes Name Initial real(kind=rk), public, allocatable :: abscissae (:,:) Abscissae (coordinates) integer(kind=ik), public :: dime = 0 Element dimension character(len=3), public :: elmtype = \"\" Element type: TRI, QUA, TET, HEX, WEJ integer(kind=ik), public :: orders (3) = 0 Order of cubature integer, public :: ounit = stdout integer(kind=ik), public :: points = 0 Number of cubature points real(kind=rk), public, allocatable :: weights (:) Weights Finalizations Procedures final :: destroy_final Type-Bound Procedures procedure, public :: check procedure, public :: destroy procedure, public :: set procedure, public :: show procedure, public :: summary Functions public pure function counter (i, j, k, r) result(c) Count in base r - indexing starts at 1 Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: i integer(kind=ik), intent(in) :: j integer(kind=ik), intent(in) :: k integer(kind=ik), intent(in) :: r (3) Return Value integer(kind=ik)","tags":"","url":"module/cubatures.html"},{"title":"cubatures_example – fortran_cubatures","text":"Uses cubatures Demonstrate cubatures Variables Type Attributes Name Initial type( Cubature ) :: scheme Source Code program cubatures_example !! Demonstrate cubatures use cubatures implicit none type ( Cubature ) :: scheme call scheme % set ( \"LIN\" ,[ 2 ]) call scheme % show () call scheme % set ( \"TRI\" ,[ 2 ]) call scheme % show () call scheme % set ( \"QUA\" ,[ 2 ]) call scheme % show () call scheme % set ( \"TET\" ,[ 2 ]) call scheme % show () call scheme % set ( \"HEX\" ,[ 2 ]) call scheme % show () call scheme % set ( \"WEJ\" ,[ 1 ]) call scheme % show () end program cubatures_example","tags":"","url":"program/cubatures_example.html"},{"title":"cubatures_test – fortran_cubatures","text":"Uses cubatures Test cubatures Variables Type Attributes Name Initial real(kind=rk) :: anasol real(kind=rk) :: coeff (10) character(len=*), parameter :: fmt1 = \"(A15,': ',$)\" integer :: i integer :: j integer :: maxo real(kind=rk) :: numsol integer :: ord character(len=1) :: order real(kind=rk) :: poly type( Cubature ) :: scheme real(kind=rk) :: vol Functions pure function ipolynomial (c, o) result(v) Evaluate polynomial integral over domain [xlo, xhi] with coefficients\nc to order o\nv = sum_i=1&#94;o+1 c_i/i xhi&#94;i - c_i xlo&#94;i Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: c (10) integer, intent(in) :: o Return Value real(kind=rk) pure elemental function is_zero (r) result(z) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: r Return Value logical pure function polynomial (c, x, o) result(v) Evaluate polynomial at x with coefficients c to order o\nv = sum_i=1&#94;o+1 c_i*x&#94;(i-1) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: c (10) real(kind=rk), intent(in) :: x integer, intent(in) :: o Return Value real(kind=rk) Source Code program cubatures_test !! Test cubatures use cubatures implicit none integer :: i , j integer :: ord integer :: maxo real ( rk ) :: vol real ( rk ) :: coeff ( 10 ) real ( rk ) :: poly real ( rk ) :: anasol , numsol character ( 1 ) :: order character ( * ), parameter :: fmt1 = \"(A15,': ',$)\" type ( cubature ) :: scheme call random_number ( coeff ) write ( * , \"(A)\" ) \"Lineatures\" write ( * , fmt1 ) \"Lines\" j = maxval ( maxloc ( index ( elmtypes , \"LIN\" ))) vol = volumes ( j ) maxo = maxorders ( j ) do i = 1 , maxo write ( order , \"(I1)\" ) i call scheme % set ( \"LIN\" , [ i ]) ! Check weight sum if (. not . is_zero ( sum ( scheme % weights ) - vol )) then error stop \"order \" // order // \": sum of weights failed\" end if ! Check abscissae balance if (. not . is_zero ( sum ( scheme % abscissae ( 1 ,:)))) then error stop \"order \" // order // \": sum of abscissae failed\" end if ord = 2 * i - 1 ! Analytical integral anasol = ipolynomial ( coeff , ord ) ! Numerical integral numsol = 0 do j = 1 , scheme % points poly = polynomial ( coeff , scheme % abscissae ( 1 , j ), ord ) numsol = numsol + poly * scheme % weights ( j ) end do ! j if (. not . is_zero ( anasol - numsol )) then write ( * , * ) write ( * , * ) anasol , numsol error stop \"order \" // order // \": integration failed\" end if end do ! i write ( * , \"(A)\" ) \"passed\" write ( * , \"(/,A)\" ) \"Quadratures\" write ( * , fmt1 ) \"Quadrilaterals\" j = maxval ( maxloc ( index ( elmtypes , \"QUA\" ))) vol = volumes ( j ) maxo = maxorders ( j ) do i = 1 , maxo write ( order , \"(I1)\" ) i call scheme % set ( \"QUA\" , [ i ]) if (. not . is_zero ( sum ( scheme % weights ) - vol )) then error stop \"order \" // order // \": sum of weights failed\" end if do j = 1 , 2 if (. not . is_zero ( sum ( scheme % abscissae ( j ,:)))) then error stop \"order \" // order // \": sum of abscissae failed\" end if end do ! j ord = 2 * i - 1 ! Analytical integral anasol = ipolynomial ( coeff , ord ) ** 2 ! Numerical integral numsol = 0 do j = 1 , scheme % points poly = polynomial ( coeff , scheme % abscissae ( 1 , j ), ord ) & * polynomial ( coeff , scheme % abscissae ( 2 , j ), ord ) numsol = numsol + poly * scheme % weights ( j ) end do ! j if (. not . is_zero ( anasol - numsol )) then write ( * , * ) write ( * , * ) anasol , numsol error stop \"order \" // order // \": integration failed\" end if end do ! i write ( * , \"(A)\" ) \"passed\" write ( * , fmt1 ) \"Triangles\" j = maxval ( maxloc ( index ( elmtypes , \"TRI\" ))) vol = volumes ( j ) maxo = maxorders ( j ) do i = 1 , maxo write ( order , \"(I1)\" ) i call scheme % set ( \"TRI\" , [ i ]) if (. not . is_zero ( sum ( scheme % weights ) - vol )) then write ( * , * ) write ( * , * ) sum ( scheme % weights ) error stop \"order \" // order // \": sum of weights failed\" end if do j = 1 , 2 if (. not . is_zero ( sum ( scheme % abscissae ( j ,:)) / scheme % points - 1.0_rk / 3 )) then write ( * , * ) write ( * , * ) sum ( scheme % abscissae ( j ,:)) error stop \"order \" // order // \": sum of abscissae failed\" end if end do ! j ! ord = 2*i-1 ! ! Analytical integral ! anasol = ipolynomial(coeff,ord)**2 ! ! Numerical integral ! numsol = 0 ! do j = 1,scheme%points !   poly = polynomial(coeff,scheme%abscissae(1,j),ord) & !         *polynomial(coeff,scheme%abscissae(2,j),ord) !   numsol = numsol + poly*scheme%weights(j) ! end do ! j ! if (.not.is_zero(anasol-numsol)) then !   write(*,*) !   write(*,*) anasol, numsol !   error stop \"order \"//order//\": integration failed\" ! end if end do ! i write ( * , \"(A)\" ) \"passed\" write ( * , \"(/,A)\" ) \"Cubatures\" write ( * , fmt1 ) \"Hexahedrons\" j = maxval ( maxloc ( index ( elmtypes , \"HEX\" ))) vol = volumes ( j ) maxo = maxorders ( j ) do i = 1 , maxo write ( order , \"(I1)\" ) i call scheme % set ( \"HEX\" , [ i ]) if (. not . is_zero ( sum ( scheme % weights ) - vol )) then error stop \"order \" // order // \": sum of weights failed\" end if do j = 1 , 3 if (. not . is_zero ( sum ( scheme % abscissae ( j ,:)))) then error stop \"order \" // order // \": sum of abscissae failed\" end if end do ! j ord = 2 * i - 1 ! Analytical integral anasol = ipolynomial ( coeff , ord ) ** 3 ! Numerical integral numsol = 0 do j = 1 , scheme % points poly = polynomial ( coeff , scheme % abscissae ( 1 , j ), ord ) & * polynomial ( coeff , scheme % abscissae ( 2 , j ), ord ) & * polynomial ( coeff , scheme % abscissae ( 3 , j ), ord ) numsol = numsol + poly * scheme % weights ( j ) end do ! j if (. not . is_zero ( anasol - numsol )) then write ( * , * ) write ( * , * ) anasol , numsol error stop \"order \" // order // \": integration failed\" end if end do ! i write ( * , \"(A)\" ) \"passed\" write ( * , fmt1 ) \"Tetrahedrons\" j = maxval ( maxloc ( index ( elmtypes , \"TET\" ))) vol = volumes ( j ) maxo = maxorders ( j ) do i = 1 , maxo write ( order , \"(I1)\" ) i call scheme % set ( \"TET\" , [ i ]) if (. not . is_zero ( sum ( scheme % weights ) - vol )) then write ( * , * ) write ( * , * ) sum ( scheme % weights ) error stop \"order \" // order // \": sum of weights failed\" end if do j = 1 , 3 if (. not . is_zero ( sum ( scheme % abscissae ( j ,:)) / scheme % points - 1.0_rk / 4 )) then write ( * , * ) write ( * , * ) sum ( scheme % abscissae ( j ,:)) error stop \"order \" // order // \": sum of abscissae failed\" end if end do ! j ! ord = 2*i-1 ! ! Analytical integral ! anasol = ipolynomial(coeff,ord)**2 ! ! Numerical integral ! numsol = 0 ! do j = 1,scheme%points !   poly = polynomial(coeff,scheme%abscissae(1,j),ord) & !         *polynomial(coeff,scheme%abscissae(2,j),ord) !   numsol = numsol + poly*scheme%weights(j) ! end do ! j ! if (.not.is_zero(anasol-numsol)) then !   write(*,*) !   write(*,*) anasol, numsol !   error stop \"order \"//order//\": integration failed\" ! end if end do ! i write ( * , \"(A)\" ) \"passed\" contains pure elemental function is_zero ( r ) result ( z ) real ( rk ), intent ( in ) :: r logical :: z z = abs ( r ) < 1 0.0_rk ** ( - 12 ) end function is_zero !*********************************************************************** pure function polynomial ( c , x , o ) result ( v ) !! Evaluate polynomial at x with coefficients c to order o !! v = sum_i=1&#94;o+1 c_i*x&#94;(i-1) real ( rk ), intent ( in ) :: c ( 10 ), x integer , intent ( in ) :: o real ( rk ) :: v integer :: i v = c ( 1 ) do i = 2 , o + 1 v = v + c ( i ) * x ** ( i - 1 ) end do ! i end function polynomial !*********************************************************************** pure function ipolynomial ( c , o ) result ( v ) !! Evaluate polynomial integral over domain [xlo, xhi] with coefficients !! c to order o !! v = sum_i=1&#94;o+1 c_i/i*xhi&#94;i - c_i*xlo&#94;i real ( rk ), intent ( in ) :: c ( 10 ) integer , intent ( in ) :: o real ( rk ) :: v real ( rk ), parameter :: xlo = - 1 , xhi = 1 integer :: i v = 0 do i = 1 , o + 1 v = v + c ( i ) * ( xhi ** i - xlo ** i ) / i end do ! i end function ipolynomial end program cubatures_test","tags":"","url":"program/cubatures_test.html"},{"title":"cubatures_example.f90 – fortran_cubatures","text":"Source Code program cubatures_example !! Demonstrate cubatures use cubatures implicit none type ( Cubature ) :: scheme call scheme % set ( \"LIN\" ,[ 2 ]) call scheme % show () call scheme % set ( \"TRI\" ,[ 2 ]) call scheme % show () call scheme % set ( \"QUA\" ,[ 2 ]) call scheme % show () call scheme % set ( \"TET\" ,[ 2 ]) call scheme % show () call scheme % set ( \"HEX\" ,[ 2 ]) call scheme % show () call scheme % set ( \"WEJ\" ,[ 1 ]) call scheme % show () end program cubatures_example","tags":"","url":"sourcefile/cubatures_example.f90.html"},{"title":"cubatures_test.f90 – fortran_cubatures","text":"Source Code program cubatures_test !! Test cubatures use cubatures implicit none integer :: i , j integer :: ord integer :: maxo real ( rk ) :: vol real ( rk ) :: coeff ( 10 ) real ( rk ) :: poly real ( rk ) :: anasol , numsol character ( 1 ) :: order character ( * ), parameter :: fmt1 = \"(A15,': ',$)\" type ( cubature ) :: scheme call random_number ( coeff ) write ( * , \"(A)\" ) \"Lineatures\" write ( * , fmt1 ) \"Lines\" j = maxval ( maxloc ( index ( elmtypes , \"LIN\" ))) vol = volumes ( j ) maxo = maxorders ( j ) do i = 1 , maxo write ( order , \"(I1)\" ) i call scheme % set ( \"LIN\" , [ i ]) ! Check weight sum if (. not . is_zero ( sum ( scheme % weights ) - vol )) then error stop \"order \" // order // \": sum of weights failed\" end if ! Check abscissae balance if (. not . is_zero ( sum ( scheme % abscissae ( 1 ,:)))) then error stop \"order \" // order // \": sum of abscissae failed\" end if ord = 2 * i - 1 ! Analytical integral anasol = ipolynomial ( coeff , ord ) ! Numerical integral numsol = 0 do j = 1 , scheme % points poly = polynomial ( coeff , scheme % abscissae ( 1 , j ), ord ) numsol = numsol + poly * scheme % weights ( j ) end do ! j if (. not . is_zero ( anasol - numsol )) then write ( * , * ) write ( * , * ) anasol , numsol error stop \"order \" // order // \": integration failed\" end if end do ! i write ( * , \"(A)\" ) \"passed\" write ( * , \"(/,A)\" ) \"Quadratures\" write ( * , fmt1 ) \"Quadrilaterals\" j = maxval ( maxloc ( index ( elmtypes , \"QUA\" ))) vol = volumes ( j ) maxo = maxorders ( j ) do i = 1 , maxo write ( order , \"(I1)\" ) i call scheme % set ( \"QUA\" , [ i ]) if (. not . is_zero ( sum ( scheme % weights ) - vol )) then error stop \"order \" // order // \": sum of weights failed\" end if do j = 1 , 2 if (. not . is_zero ( sum ( scheme % abscissae ( j ,:)))) then error stop \"order \" // order // \": sum of abscissae failed\" end if end do ! j ord = 2 * i - 1 ! Analytical integral anasol = ipolynomial ( coeff , ord ) ** 2 ! Numerical integral numsol = 0 do j = 1 , scheme % points poly = polynomial ( coeff , scheme % abscissae ( 1 , j ), ord ) & * polynomial ( coeff , scheme % abscissae ( 2 , j ), ord ) numsol = numsol + poly * scheme % weights ( j ) end do ! j if (. not . is_zero ( anasol - numsol )) then write ( * , * ) write ( * , * ) anasol , numsol error stop \"order \" // order // \": integration failed\" end if end do ! i write ( * , \"(A)\" ) \"passed\" write ( * , fmt1 ) \"Triangles\" j = maxval ( maxloc ( index ( elmtypes , \"TRI\" ))) vol = volumes ( j ) maxo = maxorders ( j ) do i = 1 , maxo write ( order , \"(I1)\" ) i call scheme % set ( \"TRI\" , [ i ]) if (. not . is_zero ( sum ( scheme % weights ) - vol )) then write ( * , * ) write ( * , * ) sum ( scheme % weights ) error stop \"order \" // order // \": sum of weights failed\" end if do j = 1 , 2 if (. not . is_zero ( sum ( scheme % abscissae ( j ,:)) / scheme % points - 1.0_rk / 3 )) then write ( * , * ) write ( * , * ) sum ( scheme % abscissae ( j ,:)) error stop \"order \" // order // \": sum of abscissae failed\" end if end do ! j ! ord = 2*i-1 ! ! Analytical integral ! anasol = ipolynomial(coeff,ord)**2 ! ! Numerical integral ! numsol = 0 ! do j = 1,scheme%points !   poly = polynomial(coeff,scheme%abscissae(1,j),ord) & !         *polynomial(coeff,scheme%abscissae(2,j),ord) !   numsol = numsol + poly*scheme%weights(j) ! end do ! j ! if (.not.is_zero(anasol-numsol)) then !   write(*,*) !   write(*,*) anasol, numsol !   error stop \"order \"//order//\": integration failed\" ! end if end do ! i write ( * , \"(A)\" ) \"passed\" write ( * , \"(/,A)\" ) \"Cubatures\" write ( * , fmt1 ) \"Hexahedrons\" j = maxval ( maxloc ( index ( elmtypes , \"HEX\" ))) vol = volumes ( j ) maxo = maxorders ( j ) do i = 1 , maxo write ( order , \"(I1)\" ) i call scheme % set ( \"HEX\" , [ i ]) if (. not . is_zero ( sum ( scheme % weights ) - vol )) then error stop \"order \" // order // \": sum of weights failed\" end if do j = 1 , 3 if (. not . is_zero ( sum ( scheme % abscissae ( j ,:)))) then error stop \"order \" // order // \": sum of abscissae failed\" end if end do ! j ord = 2 * i - 1 ! Analytical integral anasol = ipolynomial ( coeff , ord ) ** 3 ! Numerical integral numsol = 0 do j = 1 , scheme % points poly = polynomial ( coeff , scheme % abscissae ( 1 , j ), ord ) & * polynomial ( coeff , scheme % abscissae ( 2 , j ), ord ) & * polynomial ( coeff , scheme % abscissae ( 3 , j ), ord ) numsol = numsol + poly * scheme % weights ( j ) end do ! j if (. not . is_zero ( anasol - numsol )) then write ( * , * ) write ( * , * ) anasol , numsol error stop \"order \" // order // \": integration failed\" end if end do ! i write ( * , \"(A)\" ) \"passed\" write ( * , fmt1 ) \"Tetrahedrons\" j = maxval ( maxloc ( index ( elmtypes , \"TET\" ))) vol = volumes ( j ) maxo = maxorders ( j ) do i = 1 , maxo write ( order , \"(I1)\" ) i call scheme % set ( \"TET\" , [ i ]) if (. not . is_zero ( sum ( scheme % weights ) - vol )) then write ( * , * ) write ( * , * ) sum ( scheme % weights ) error stop \"order \" // order // \": sum of weights failed\" end if do j = 1 , 3 if (. not . is_zero ( sum ( scheme % abscissae ( j ,:)) / scheme % points - 1.0_rk / 4 )) then write ( * , * ) write ( * , * ) sum ( scheme % abscissae ( j ,:)) error stop \"order \" // order // \": sum of abscissae failed\" end if end do ! j ! ord = 2*i-1 ! ! Analytical integral ! anasol = ipolynomial(coeff,ord)**2 ! ! Numerical integral ! numsol = 0 ! do j = 1,scheme%points !   poly = polynomial(coeff,scheme%abscissae(1,j),ord) & !         *polynomial(coeff,scheme%abscissae(2,j),ord) !   numsol = numsol + poly*scheme%weights(j) ! end do ! j ! if (.not.is_zero(anasol-numsol)) then !   write(*,*) !   write(*,*) anasol, numsol !   error stop \"order \"//order//\": integration failed\" ! end if end do ! i write ( * , \"(A)\" ) \"passed\" contains pure elemental function is_zero ( r ) result ( z ) real ( rk ), intent ( in ) :: r logical :: z z = abs ( r ) < 1 0.0_rk ** ( - 12 ) end function is_zero !*********************************************************************** pure function polynomial ( c , x , o ) result ( v ) !! Evaluate polynomial at x with coefficients c to order o !! v = sum_i=1&#94;o+1 c_i*x&#94;(i-1) real ( rk ), intent ( in ) :: c ( 10 ), x integer , intent ( in ) :: o real ( rk ) :: v integer :: i v = c ( 1 ) do i = 2 , o + 1 v = v + c ( i ) * x ** ( i - 1 ) end do ! i end function polynomial !*********************************************************************** pure function ipolynomial ( c , o ) result ( v ) !! Evaluate polynomial integral over domain [xlo, xhi] with coefficients !! c to order o !! v = sum_i=1&#94;o+1 c_i/i*xhi&#94;i - c_i*xlo&#94;i real ( rk ), intent ( in ) :: c ( 10 ) integer , intent ( in ) :: o real ( rk ) :: v real ( rk ), parameter :: xlo = - 1 , xhi = 1 integer :: i v = 0 do i = 1 , o + 1 v = v + c ( i ) * ( xhi ** i - xlo ** i ) / i end do ! i end function ipolynomial end program cubatures_test","tags":"","url":"sourcefile/cubatures_test.f90.html"},{"title":"cubatures.f90 – fortran_cubatures","text":"Source Code module cubatures !! Define cubature derived type use iso_fortran_env , only : ik => int32 , rk => real64 , stdout => output_unit implicit none private public :: ik , rk character ( 3 ), parameter :: elmtypes ( * ) = & [ \"LIN\" , \"TRI\" , \"QUA\" , \"TET\" , \"HEX\" , \"WEJ\" ] real ( rk ), parameter :: volumes ( * ) = & [ 2.0_rk , 1.0_rk / 2 , 4.0_rk , 1.0_rk / 6 , 8.0_rk , 1.0_rk ] integer , parameter :: maxorders ( * ) = & [ 5 , 3 , 5 , 3 , 5 , 2 ] public :: elmtypes , volumes , maxorders type :: Cubature !! This derived type holds data, weights, and abscissae for numerical !! integration of 2D (triangle, quadrilaterals) and 3D bodies (tetrahedra, !! hexahedra, and wedges) !! !! Note: Cubatures for tetrahedra use body coordinates, and the condition !!       x1 + x2 + x3 + x4 = 1 permits the elimination of the final !!       coordinate character ( 3 ) :: elmtype = \"\" !! Element type: TRI, QUA, TET, HEX, WEJ integer ( ik ) :: dime = 0 !! Element dimension integer ( ik ) :: orders ( 3 ) = 0 !! Order of cubature integer ( ik ) :: points = 0 !! Number of cubature points real ( rk ), allocatable :: abscissae (:,:) !! Abscissae (coordinates) real ( rk ), allocatable :: weights (:) !! Weights integer :: ounit = stdout contains ! Fulfill object requirements procedure :: check procedure :: summary procedure :: show procedure :: destroy ! Unique procedures procedure :: set final :: destroy_final end type Cubature public :: Cubature public :: counter contains !*********************************************************************** pure function check ( self ) !! Check integrity of derived type class ( cubature ), intent ( in ) :: self logical :: check check = ( allocated ( self % abscissae ) . neqv . allocated ( self % weights )) end function check !*********************************************************************** subroutine summary ( self ) !! Summarize cubature scheme class ( cubature ), intent ( in ) :: self associate ( u => self % ounit ) write ( u , \"(A20,A)\" ) \"Element type: \" , self % elmtype write ( u , \"(A20,I0)\" ) \"Element dimension: \" , self % dime write ( u , \"(A20,3(I1,:,','))\" ) \"Element orders: \" , self % orders write ( u , \"(A20,I0)\" ) \"Element points: \" , self % points end associate end subroutine summary !*********************************************************************** subroutine show ( self ) !! Print cubature scheme to output class ( Cubature ), intent ( in ) :: self integer ( ik ) :: i character ( * ), parameter :: fmt0 = \"*(G0,:,', ')\" character ( * ), parameter :: fmt1 = \"(I3,')',1x,\" // fmt0 // \")\" character ( * ), parameter :: fmt2 = \"('Chk:',1x,\" // fmt0 // \")\" write ( self % ounit , \"(A)\" ) \"CUBATURE DATA\" select case ( self % elmtype ) ! Information on lines case ( \"LIN\" ) write ( self % ounit , \"(A,1I2,1x,A)\" ) \"LIN\" , self % orders ( 1 ), \"Abscissae (1), Weight\" do i = 1 , self % points write ( self % ounit , fmt1 ) i , self % abscissae (:, i ), self % weights ( i ) end do ! i write ( self % ounit , fmt2 ) sum ( self % abscissae ( 1 ,:)), sum ( self % weights ) ! Information on quadrilaterals case ( \"QUA\" ) write ( self % ounit , \"(A,2I2,1x,A)\" ) \"QUA\" , self % orders ( 1 : 2 ), \"Abscissae (2), Weight\" do i = 1 , self % points write ( self % ounit , fmt1 ) i , self % abscissae (:, i ), self % weights ( i ) end do ! i write ( self % ounit , fmt2 ) ( sum ( self % abscissae ( i ,:)), i = 1 , 2 ), sum ( self % weights ) ! Information on triangles case ( \"TRI\" ) write ( self % ounit , \"(A,1I2,1x,A)\" ) \"TRI\" , self % orders ( 1 ), \"Abscissae (2), Coord 3, Weight\" do i = 1 , self % points write ( self % ounit , fmt1 ) i , & self % abscissae (:, i ), & 1 - sum ( self % abscissae (:, i )), self % weights ( i ) end do ! i write ( self % ounit , fmt2 ) ( sum ( self % abscissae ( i ,:)) / self % points , i = 1 , 2 ), & 1 - sum ( self % abscissae (:,:)) / self % points , & sum ( self % weights ) ! Information on hexahedra case ( \"HEX\" ) write ( self % ounit , \"(A,3I2,1x,A)\" ) \"HEX\" , self % orders , \"Abscissae (3), Weight\" do i = 1 , self % points write ( self % ounit , fmt1 ) i , self % abscissae (:, i ), self % weights ( i ) end do ! i write ( self % ounit , fmt2 ) ( sum ( self % abscissae ( i ,:)), i = 1 , 3 ), sum ( self % weights ) ! Information on tetrahedra case ( \"TET\" ) write ( self % ounit , \"(A,1I2,1x,A)\" ) \"TET\" , self % orders ( 1 ), \"Abscissae (3), Coord 4, Weight\" do i = 1 , self % points write ( self % ounit , fmt1 ) i , & self % abscissae (:, i ), & 1 - sum ( self % abscissae (:, i )), self % weights ( i ) end do ! i write ( self % ounit , fmt2 ) ( sum ( self % abscissae ( i ,:)) / self % points , i = 1 , 3 ), & 1 - sum ( self % abscissae (:,:)) / self % points , & sum ( self % weights ) ! Information on wedges case ( \"WEJ\" ) write ( self % ounit , \"(A,1I2,1x,A)\" ) \"WEJ\" , self % orders ( 1 ), \"Abscissae (1-2), Coord 3, Abscissa 3, Weight\" do i = 1 , self % points write ( self % ounit , fmt1 ) i , & self % abscissae ( 1 : 2 , i ), & 1 - sum ( self % abscissae ( 1 : 2 , i )), & self % abscissae ( 3 , i ), & self % weights ( i ) end do ! i write ( self % ounit , fmt2 ) sum ( self % abscissae ( 1 ,:)) / self % points , & sum ( self % abscissae ( 2 ,:)) / self % points , & 1 - sum ( self % abscissae ( 1 : 2 ,:)) / self % points , & sum ( self % abscissae ( 3 ,:)) / self % points , & sum ( self % weights ) end select write ( self % ounit , * ) end subroutine show !*********************************************************************** pure subroutine destroy ( self ) !! wipe data and memory class ( Cubature ), intent ( inout ) :: self self % elmtype = \"\" self % orders = 0 self % points = 0 if ( allocated ( self % abscissae )) deallocate ( self % abscissae ) if ( allocated ( self % weights )) deallocate ( self % weights ) self % ounit = stdout end subroutine destroy !*********************************************************************** pure subroutine destroy_final ( self ) !! Destroy derived type type ( Cubature ), intent ( inout ) :: self call self % destroy () end subroutine destroy_final !*********************************************************************** pure subroutine set ( self , elmtype , order ) !! Set cubature scheme by inputting shape and order class ( Cubature ), intent ( inout ) :: self character ( 3 ), intent ( in ) :: elmtype !! Element type: TRI, QUA, TET, HEX, WEJ integer ( ik ), intent ( in ) :: order (:) !! Cubature order: size 1 or dimension integer ( ik ) :: i , j , k !! Iterators integer ( ik ) :: n !! Index of abscissae ! Wipe any existing data call self % destroy () ! Set data self % elmtype = elmtype select case ( self % elmtype ) case ( \"LIN\" ) self % dime = 1 case ( \"TRI\" , \"QUA\" ) self % dime = 2 case ( \"HEX\" , \"TET\" , \"WEJ\" ) self % dime = 3 end select ! Read order select case ( size ( order , 1 )) case ( 1 ) self % orders ( 1 ) = order ( 1 ) if ( self % orders ( 1 ) > 0 ) then self % orders ( 1 : self % dime ) = order ( 1 ) self % orders ( self % dime + 1 : 3 ) = 1 end if case ( 2 ) if (( self % elmtype == \"HEX\" ) . or . ( self % elmtype == \"TET\" ) . or . ( self % elmtype == \"WEJ\" )) then error stop \"cubatures%set: Invalid order array for 3D\" end if if ( self % elmtype == \"LIN\" ) then error stop \"cubatures%set: Invalid order array for 1D\" end if self % orders ( 1 : 2 ) = order self % orders ( 3 ) = 1 case ( 3 ) if (( self % elmtype == \"QUA\" ) . or . ( self % elmtype == \"TRI\" )) then error stop \"cubatures%set: Invalid order array for 2D\" end if if ( self % elmtype == \"LIN\" ) then error stop \"cubatures%set: Invalid order array for 1D\" end if self % orders = order end select select case ( self % elmtype ) case ( \"LIN\" ) self % points = self % orders ( 1 ) ! Allocate memory allocate ( self % abscissae ( 1 : 1 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ) :: abscissae ( maxval ( self % orders )) real ( rk ) :: weights ( maxval ( self % orders )) ! Retrieve lineature call gauss ( self % orders ( 1 ), abscissae , weights ) ! Accumulate cubature do i = 1 , self % orders ( 1 ) n = counter ( i , 1 , 1 , self % orders ) self % abscissae ( 1 , n ) = abscissae ( i ) self % weights ( n ) = weights ( i ) end do ! i end block case ( \"QUA\" ) self % points = self % orders ( 1 ) * self % orders ( 2 ) ! Allocate memory allocate ( self % abscissae ( 1 : 2 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ) :: abscissae ( maxval ( self % orders ), 2 ) real ( rk ) :: weights ( maxval ( self % orders ), 2 ) ! Retrieve lineature call gauss ( self % orders ( 1 ), abscissae (:, 1 ), weights (:, 1 )) call gauss ( self % orders ( 2 ), abscissae (:, 2 ), weights (:, 2 )) ! Accumulate cubature do i = 1 , self % orders ( 1 ) do j = 1 , self % orders ( 2 ) n = counter ( i , j , 1 , self % orders ) self % abscissae (:, n ) = [ abscissae ( i , 1 ), abscissae ( j , 2 )] self % weights ( n ) = weights ( i , 1 ) * weights ( j , 2 ) end do ! j end do ! i end block case ( \"TRI\" ) select case ( self % orders ( 1 )) ! 1-Point triangle quadrature case ( 1 ) self % points = 1 allocate ( self % abscissae ( 1 : 2 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) self % abscissae (:, 1 ) = 1.0_rk / 3 self % weights ( 1 ) = 1.0_rk / 2 ! 3-Point triangle quadrature - interior (see Zienkiewicz & Taylor) case ( 2 ) self % points = 3 allocate ( self % abscissae ( 1 : 2 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) self % abscissae = 1.0_rk / 6 self % abscissae ( 1 , 1 ) = 2.0_rk / 3 self % abscissae ( 2 , 2 ) = 2.0_rk / 3 self % weights = 1.0_rk / 6 ! 4-Point triangle quadrature - interior case ( 3 ) self % points = 4 allocate ( self % abscissae ( 1 : 2 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) self % abscissae (:, 1 ) = 1.0_rk / 3 self % abscissae (:, 2 : 4 ) = 0.2_rk self % abscissae ( 1 , 2 ) = 0.6_rk self % abscissae ( 2 , 3 ) = 0.6_rk self % weights ( 1 ) = - 2 7.0_rk / 96 self % weights ( 2 : 4 ) = 2 5.0_rk / 96 case default error stop \"Cubature%set: Invalid order for triangle\" end select case ( \"HEX\" ) if ( self % orders ( 2 ) > 0 ) then self % points = product ( self % orders ) ! Allocate memory allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ) :: abscissae ( maxval ( self % orders ), 3 ) real ( rk ) :: weights ( maxval ( self % orders ), 3 ) ! Retrieve lineature do i = 1 , 3 call gauss ( self % orders ( i ), abscissae (:, i ), weights (:, i )) end do ! i ! Accumulate cubature do i = 1 , self % orders ( 1 ) do j = 1 , self % orders ( 2 ) do k = 1 , self % orders ( 3 ) n = counter ( i , j , k , self % orders ) self % abscissae (:, n ) = [ abscissae ( i , 1 ), abscissae ( j , 2 ), abscissae ( k , 3 )] self % weights ( n ) = weights ( i , 1 ) * weights ( j , 2 ) * weights ( k , 3 ) end do ! k end do ! j end do ! i end block ! 4-Point hexahedron cubature else if ( self % orders ( 1 ) == - 4 ) then self % points = 4 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ), parameter :: sqrt13 = sqrt ( 1.0_rk / 3 ) self % abscissae (:, 1 ) = [ - sqrt13 , - sqrt13 , - sqrt13 ] self % abscissae (:, 2 ) = [ sqrt13 , sqrt13 , - sqrt13 ] self % abscissae (:, 3 ) = [ sqrt13 , - sqrt13 , sqrt13 ] self % abscissae (:, 4 ) = [ - sqrt13 , sqrt13 , sqrt13 ] self % weights = 2 end block ! 9-Point hexahedron cubature else if ( self % orders ( 1 ) == - 9 ) then self % points = 9 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ), parameter :: sqrt35 = sqrt ( 3.0_rk / 5 ) real ( rk ), parameter :: tick ( 1 : 2 ) = [ - sqrt35 , sqrt35 ] self % weights ( 1 : 8 ) = 5.0_rk / 9 self % weights ( 9 ) = 3 2.0_rk / 9 do i = 1 , 2 do j = 1 , 2 do k = 1 , 2 n = counter ( i , j , k ,[ 2 , 2 , 2 ]) self % abscissae (:, n ) = [ tick ( k ), tick ( j ), tick ( i )] end do ! k end do ! j end do ! i self % abscissae (:, 9 ) = 0 end block else error stop \"Cubature%set: Invalid order for hexahedron\" end if case ( \"TET\" ) select case ( self % orders ( 1 )) ! 1-Point tetrahedron cubature case ( 1 ) self % points = 1 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) self % abscissae (:, 1 ) = 0.25_rk self % weights ( 1 ) = 1.0_rk / 6 ! 4-Point tetrahedron cubature - interior (see Zienkiewicz & Taylor) case ( 2 ) self % points = 4 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ), parameter :: alpha = 0.5854101966249685_rk real ( rk ), parameter :: beta = 0.1381966011250105_rk self % abscissae = beta do i = 1 , 3 self % abscissae ( i , i ) = alpha end do ! i end block self % weights = 1.0_rk / 24 ! 5-Point tetrahedron cubature - interior case ( 3 ) self % points = 5 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) self % abscissae (:, 1 : 4 ) = 1.0_rk / 6 self % abscissae ( 1 , 1 ) = 0.5_rk self % abscissae ( 2 , 2 ) = 0.5_rk self % abscissae ( 3 , 3 ) = 0.5_rk self % abscissae (:, 5 ) = 0.25_rk self % weights ( 1 : 4 ) = 0.45_rk / 6 self % weights ( 5 ) = - 0.8_rk / 6 case default error stop \"Cubature%set: Invalid order for tetrahedron\" end select case ( \"WEJ\" ) select case ( self % orders ( 1 )) ! 2-Point wedge cubature case ( 1 ) self % points = 2 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ) :: abscissae ( 2 ) real ( rk ) :: weights ( 2 ) call gauss ( 2 , abscissae , weights ) self % abscissae ( 1 : 2 ,:) = 1.0_rk / 3 self % abscissae ( 3 ,:) = abscissae self % weights = weights / 2 end block ! 9-Point wedge cubature case ( 2 ) self % points = 9 allocate ( self % abscissae ( 1 : 3 , 1 : self % points )) allocate ( self % weights ( 1 : self % points )) block real ( rk ) :: abscissae ( 3 ) real ( rk ) :: weights ( 3 ) call gauss ( 3 , abscissae , weights ) self % abscissae ( 1 : 2 ,:) = 1.0_rk / 6 self % abscissae ( 1 , 1 ) = 2.0_rk / 3 self % abscissae ( 2 , 2 ) = 2.0_rk / 3 self % abscissae ( 1 , 4 ) = 2.0_rk / 3 self % abscissae ( 2 , 5 ) = 2.0_rk / 3 self % abscissae ( 1 , 7 ) = 2.0_rk / 3 self % abscissae ( 2 , 8 ) = 2.0_rk / 3 self % abscissae ( 3 , 1 : 3 ) = abscissae ( 1 ) self % abscissae ( 3 , 4 : 6 ) = abscissae ( 2 ) self % abscissae ( 3 , 7 : 9 ) = abscissae ( 3 ) self % weights ( 1 : 3 ) = weights ( 1 ) / 6 self % weights ( 4 : 6 ) = weights ( 2 ) / 6 self % weights ( 7 : 9 ) = weights ( 3 ) / 6 end block case default error stop \"Cubature%set: Invalid order for wedge\" end select case default error stop \"Cubature%set: Invalid element type\" end select end subroutine set !*********************************************************************** pure function counter ( i , j , k , r ) result ( c ) !! Count in base r - indexing starts at 1 integer ( ik ), intent ( in ) :: i , j , k , r ( 3 ) integer ( ik ) :: c c = r ( 2 ) * r ( 3 ) * ( i - 1 ) + r ( 3 ) * ( j - 1 ) + ( k - 1 ) + 1 end function counter !*********************************************************************** pure subroutine gauss ( order , abscissae , weights ) !! Provide Gaussian lineature abscissae and weights given the order, for domain [-1, 1] integer ( ik ), intent ( in ) :: order !! Order of integration real ( rk ), intent ( out ) :: abscissae ( order ) !! Abscissae (coordinates) real ( rk ), intent ( out ) :: weights ( order ) !! Weights select case ( order ) ! 1 point case ( 1 ) abscissae ( 1 ) = 0 weights ( 1 ) = 2 ! 2 point case ( 2 ) block real ( rk ), parameter :: sqrt13 = sqrt ( 1.0_rk / 3 ) abscissae = [ - sqrt13 , sqrt13 ] weights = [ 1.0_rk , 1.0_rk ] end block ! 3 point case ( 3 ) block real ( rk ), parameter :: sqrt35 = sqrt ( 0.6_rk ) real ( rk ), parameter :: frac59 = 5.0_rk / 9 real ( rk ), parameter :: frac89 = 8.0_rk / 9 abscissae = [ - sqrt35 , 0.0_rk , sqrt35 ] weights = [ frac59 , frac89 , frac59 ] end block ! 4 point case ( 4 ) block real ( rk ), parameter :: sr4d8 = sqrt ( 4.8_rk ) real ( rk ), parameter :: sr30 = sqrt ( 3 0.0_rk ) real ( rk ), parameter :: root1 = sqrt (( 3.0_rk - sr4d8 ) / 7 ) real ( rk ), parameter :: root2 = sqrt (( 3.0_rk + sr4d8 ) / 7 ) real ( rk ), parameter :: frac1 = 0.5_rk + sr30 / 36 real ( rk ), parameter :: frac2 = 0.5_rk - sr30 / 36 abscissae = [ - root2 , - root1 , root1 , root2 ] weights = [ frac2 , frac1 , frac1 , frac2 ] end block ! 5 point case ( 5 ) block real ( rk ), parameter :: sr107 = sqrt ( 1 0.0_rk / 7 ) real ( rk ), parameter :: sr70 = sqrt ( 7 0.0_rk ) real ( rk ), parameter :: root1 = sqrt ( 5.0_rk - 2 * sr107 ) / 3 real ( rk ), parameter :: root2 = sqrt ( 5.0_rk + 2 * sr107 ) / 3 real ( rk ), parameter :: frac1 = ( 32 2.0_rk + 13 * sr70 ) / 900 real ( rk ), parameter :: frac2 = ( 32 2.0_rk - 13 * sr70 ) / 900 abscissae = [ - root2 , - root1 , 0.0_rk , root1 , root2 ] weights = [ frac2 , frac1 , 12 8.0_rk / 225 , frac1 , frac2 ] end block end select end subroutine gauss !*********************************************************************** end module cubatures","tags":"","url":"sourcefile/cubatures.f90.html"}]}